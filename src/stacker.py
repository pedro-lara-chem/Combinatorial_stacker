import numpy as np
from itertools import product
import os
import argparse
import sys

class CombinatorialStacker:
    def __init__(self, filepath):
        self.atoms = []  # List of atomic symbols
        self.base_coords = [] # Initial coordinates from file
        self.filepath = os.path.abspath(filepath) # Store absolute path
        self.read_xyz()
        
    def read_xyz(self):
        """Reads a standard .xyz file and centers the molecule."""
        if not os.path.exists(self.filepath):
            print(f"Error: File not found at {self.filepath}")
            sys.exit(1)

        with open(self.filepath, 'r') as f:
            lines = f.readlines()
            # Basic validation for XYZ format
            if len(lines) < 3:
                print("Error: Invalid XYZ file format (too short).")
                sys.exit(1)

            for line in lines[2:]:
                parts = line.split()
                if len(parts) >= 4:
                    self.atoms.append(parts[0])
                    # Store as floats
                    self.base_coords.append([float(parts[1]), float(parts[2]), float(parts[3])])
        
        self.base_coords = np.array(self.base_coords)
        
        # Center the molecule's geometric center (centroid) to (0,0,0)
        if len(self.base_coords) > 0:
            centroid = np.mean(self.base_coords, axis=0)
            self.base_coords = self.base_coords - centroid
        else:
            print("Error: No atoms found in file.")
            sys.exit(1)

    def rotate_molecule(self, coords, angle_degrees):
        """Rotates coordinates around the Z-axis (XY plane rotation)."""
        theta = np.radians(angle_degrees)
        c, s = np.cos(theta), np.sin(theta)
        
        # Z-axis rotation matrix
        Rz = np.array(((c, -s, 0), 
                       (s, c, 0), 
                       (0, 0, 1)))
        
        return np.dot(coords, Rz)

    def generate_combinations(self, num_copies):
        """
        Generates geometries based on combinatorial rotations and fixed displacements.
        """
        if num_copies < 2:
            print("Warning: Generating a stack with only 1 copy is just the original molecule.")

        # Define parameters for the stack:
        Z_DISPLACEMENT = 6.0 # Ångströms up (Z-axis) per copy
        X_DISPLACEMENT = 5.0 # Ångströms sideways (X-axis) per copy
        ROTATION_STEP = 30   # Degrees per step

        # Generate all possible rotation angles (0, 30, 60, ..., 330)
        rotation_angles = list(range(0, 360, ROTATION_STEP))
        
        # Generate all combinations of rotations for N molecules
        all_combinations = product(rotation_angles, repeat=num_copies)
        
        # Create output directory in the CURRENT WORKING DIRECTORY (where user runs the command)
        cwd = os.getcwd()
        output_dir = os.path.join(cwd, "stacked_geometries")
        os.makedirs(output_dir, exist_ok=True)
        
        print(f"Output directory: {output_dir}")
        
        num_generated = 0

        for rotation_tuple in all_combinations:
            stacked_atoms = []
            stacked_coords = []
            
            rotation_string = "_".join(map(str, rotation_tuple))

            for i in range(num_copies):
                angle = rotation_tuple[i] 
                
                # 1. Start with base coords
                current_coords = self.base_coords.copy()
                
                # 2. Rotate
                current_coords = self.rotate_molecule(current_coords, angle)
                
                # 3. Translate
                translation = np.array([X_DISPLACEMENT * i, 
                                        0.0, 
                                        Z_DISPLACEMENT * i])
                                        
                current_coords = current_coords + translation
                
                stacked_atoms.extend(self.atoms)
                stacked_coords.extend(current_coords)
            
            # Save
            filename = os.path.join(output_dir, f"complex_rot_{rotation_string}.xyz")
            self.save_xyz(filename, stacked_atoms, np.array(stacked_coords))
            num_generated += 1
            
        print(f"Successfully generated {num_generated} geometries.")


    def save_xyz(self, filename, atoms, coords):
        """Saves the final coordinates to an XYZ file."""
        with open(filename, 'w') as f:
            f.write(f"{len(atoms)}\n")
            f.write(f"Generated by CombinatorialStacker - Rotations: {filename.split('_')[-1].split('.')[0]} deg\n")
            for atom, coord in zip(atoms, coords):
                f.write(f"{atom:<4} {coord[0]:.6f} {coord[1]:.6f} {coord[2]:.6f}\n")

# --- MAIN EXECUTION BLOCK ---
if __name__ == "__main__":
    # Initialize Argument Parser
    parser = argparse.ArgumentParser(description="Generate combinatorial stacked geometries from an XYZ file.")
    
    # Arguments
    parser.add_argument("input_file", help="Path to the input .xyz file")
    parser.add_argument("-n", "--num_copies", type=int, default=2, help="Number of molecule copies to stack (default: 2)")
    
    # Parse arguments
    args = parser.parse_args()

    # Run Logic
    try:
        # Resolve the input path relative to where the user is
        input_path = os.path.abspath(args.input_file)
        print(f"Processing file: {input_path}")
        
        stacker = CombinatorialStacker(input_path)
        print(f"Molecule loaded. {len(stacker.atoms)} atoms.")
        print(f"Generating combinations for {args.num_copies} copies...")
        
        stacker.generate_combinations(args.num_copies)
        
    except KeyboardInterrupt:
        print("\nProcess interrupted by user.")
        sys.exit(0)
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        sys.exit(1)
